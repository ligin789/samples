import React, { useEffect, useState } from "react";
import {
  ComposedChart,
  XAxis,
  YAxis,
  Tooltip,
  Legend,
  CartesianGrid,
  Bar,
  Line,
  Scatter,
  ReferenceLine,
  Area,
  ResponsiveContainer,
  AreaChart,
} from "recharts";
import "./Graph.css";
import moment from "moment";
// import { TransformWrapper, TransformComponent } from "react-zoom-pan-pinch";

const data = [
  {
    date: "2023-07-27 22:30:33",
    targetDep: "40",
    actDep: "42",
    noOfDep: 123,
  },
  {
    date: "2023-07-28 18:30:33",
    targetDep: "41",
    actDep: "43",
    noOfDep: 123,
  },
  {
    date: "2023-07-29 12:30:33",
    targetDep: "43",
    actDep: "44",
    noOfDep: 123,
  },
  {
    date: "2023-07-30 20:30:33",
    targetDep: "45",
    actDep: "47",
    noOfDep: 123,
  },
  {
    date: "2023-07-01 22:10:33",
    targetDep: "44",
    actDep: "41",
    noOfDep: 123,
  },
  {
    date: "2023-07-02 14:30:33",
    targetDep: "40",
    actDep: "42",
    noOfDep: 123,
  },
  {
    date: "2023-07-03 23:30:33",
    targetDep: "44",
    actDep: "43",
    noOfDep: 123,
  },
  {
    date: "2023-07-04 02:30:33",
    targetDep: "43",
    actDep: "44",
    noOfDep: 123,
  },
  {
    date: "2023-07-05 07:30:33",
    targetDep: "45",
    actDep: "47",
    noOfDep: 123,
  },
  {
    date: "2023-07-06 09:30:33",
    targetDep: "44",
    actDep: "41",
    noOfDep: 123,
  },
];

const Graph = (props: any) => {
  const { processData } = props;
  const [graphData, setgraphData] = useState([]);
  const [isSingleMonth, setisSingleMonth] = useState(false)

  useEffect(() => {
    let temp: any = [];
    processData?.graphdate?.forEach((item: any, index: number) =>
      item?.processData?.forEach((pData: any) => {
        // console.log(graphData,'i am here or not for check only ====>')
        // if(Math.round(pData.processDuration)<400){
        temp.push({
          // date: moment(pData.flighttime, "YYYY-MM-DDTHH:mm:SSZ")?.format(
          //   "YYYY-MM-DD HH:mm:ss"
          date: moment(pData.flighttime, "YYYY-MM-DDTHH:mm:SS")?.format(
            "YYYY-MM-DD HH:mm:SS" 
          ),
          targetDep: Math.round(pData.processDuration),
          actDep: Math.round(pData.processDuration),
          noOfDep: item.noOfDepartures,
        });
        // }
      })
    );
    setgraphData(temp);
    setisSingleMonth(isSingleMonthFun(temp))
    // console.log("graphData", temp);
  }, [processData]);

  const CustomLegent = ({ payload }: any) => {
    return (
      <ul>
        {payload.map((entry: any, index: number) => {
          // console.log("CustomLegent", entry);
          return (
            <li>
              <span>{entry.value}</span>
            </li>
          );
        })}
      </ul>
    );
  };

  const GetRefLine = (color: any, isDashed: any, value: any = 0) => {
    // console.log(" color, isDashed ", color, isDashed, value);

    return (
      <ReferenceLine
        y={value}
        stroke={color}
        strokeDasharray={isDashed ? "8 8" : "0 0"}
      />
    );
  };

  const getColor = (name: any) => {
    switch (name.toLowerCase()) {
      case "min":
        return "#2AB1F7";
      case "max":
        return "#FA0319";
      default:
        return "#17C43D";
    }
  };

  const GetReferenceLine = () => {
    // console.log("isDashed", Object.keys(processData.target));
    return (
      <>
        {Object.keys(processData.target).map((keyName, index) =>
          GetRefLine(
            getColor(keyName),
            true,
            Number.isInteger(processData.target[keyName])
              ? processData.target[keyName]
              : 0
          )
        )}
        {Object.keys(processData.actual).map((keyName, index) =>
          GetRefLine(
            getColor(keyName),
            false,
            Number.isInteger(processData.actual[keyName])
              ? processData.actual[keyName]
              : 0
          )
        )}
      </>
    );
  };
  let uniqueDates:any = [];
  const isSingleMonthFun = (data:any) => {
    let temp:any = []
    data.forEach((element:any) => {
      // let monthYear = moment(element.date,'YYYY-MM-DD HH:mm:ss')?.format('MMM YY')
      let monthYear = moment(element.date,'YYYY-MM-DD HH:mm:SS')?.format('MMM YY')
      // console.log("isSingleMonthFun",temp,monthYear);
      if(!temp.includes(monthYear)){
        temp.push(monthYear)
      }
    });
    
    if(temp.length <= 1){
      return true
    }
    return false
  }
  const CustomXAxisTick = ({ x, y, payload, index, ticks }: any) => {
    // console.log("CustomXAxisTick",uniqueDates,x, y, payload, index, ticks);
    console.log(payload,'i am here or not for check only ====>')
    
    // const formattedDate = moment(payload.value)?.format("MMM-yyyy");
    const formattedDate = moment(payload.value,'YYYY-MM-DD HH:mm:SS')?.format("MMM-yyyy");
    // console.log("CustomXAxisTick",x, y, payload, index, ticks);
    if(isSingleMonth){
      if(graphData.length/2 == index){
        return (
          <g transform={`translate(${x},${y})`}>
            <text x={0} y={0} dy={16} textAnchor="middle" //fill="#666"
            >
              {formattedDate}
            </text>
          </g>
        );
      }
      return null;
    }else if (!uniqueDates.includes(formattedDate)) {
      // console.log(graphData,formattedDate,'i am here or not for check only ====>',x,y)
      // console.log(formattedDate,'i am here or not for check only ====>',x,y)
      uniqueDates.push(formattedDate)
      console.log("CustomXAxisTick",uniqueDates,formattedDate);
      return (
        <g transform={`translate(${x},${y})`}>
          <text x={0} y={0} dy={16} textAnchor="middle" //fill="#666"
          >
            {formattedDate}
          </text>
        </g>
      );
    }
    return null;
  };

  const labelFormatter = (date: any) =>
    // moment(date, "YYYY-MM-DD HH:mm:ss")?.format("MMM YY");
  moment(date, "YYYY-MM-DD HH:mm:SS")?.format("MMM YY");

  return (
    // <TransformWrapper>
    //   <TransformComponent>
        <div style={{ height: "450px", width: "100%" }}>
          {graphData ? (
            <ResponsiveContainer width="100%" height="100%">
              <ComposedChart
                width={1300}
                height={438}
                data={graphData}
                // data={data}
                margin={{ top: 10, right: 30, left: 0, bottom: 0 }}
              >
                <>{console.log('check the graph data ====> ',graphData)}</>
                <defs>
                  <linearGradient id="colorTarget" x1="0" y1="0" x2="0" y2="1">
                    <stop offset="5%" stopColor="#0062FF" stopOpacity={0.6} />
                    <stop offset="95%" stopColor="#0062FF" stopOpacity={0} />
                  </linearGradient>
                  <linearGradient id="colorActual" x1="0" y1="0" x2="0" y2="1">
                    <stop offset="5%" stopColor="#0062FF" stopOpacity={0.4} />
                    <stop offset="95%" stopColor="#0062FF" stopOpacity={0} />
                  </linearGradient>
                </defs>
                <XAxis
                  dataKey="date"
                  // tickLine={false}
                  axisLine={true}
                  // tickFormatter={labelFormatter}
                  tick={<CustomXAxisTick />}
                  interval={0}
                />
                <YAxis
                  label={{
                    value: "MINUTES",
                    angle: -90,
                    position: "outsideLeft",
                    fill: "#2680EB",
                  }}
                  tick={{ fill: "#2680EB" }}
                  // dx={2}
                  tickSize={10}
                  domain={[0, 100]}
                  width={80}
                  // interval={0}
                />
                <YAxis
                  label={{
                    value: "DEPARTURE",
                    angle: -90,
                    position: "outsideRight",
                    fill: "#999999",
                  }}
                  tickSize={0}
                  dx={5}
                  yAxisId="right"
                  orientation="right"
                  dataKey="noOfDep"
                  ticks={[100, 200, 300, 400, 500]}
                  tick={{ fill: "#999999" }}
                  // axisLine={false}
                  width={90}
                />
                {/* <Bar
              dataKey="noOfDep"
              yAxisId="right"
              barSize={1.8}
              fill="#8884d8"
            /> */}
                {GetReferenceLine()}
                <Tooltip />
                {/* <Legend /> */}
                <Area
                  strokeDasharray="8 8"
                  type="monotone"
                  dataKey="targetDep"
                  stroke="#0062FF"
                  fillOpacity={1}
                  fill="url(#colorTarget)"
                />
                <Area
                  type="monotone"
                  dataKey="actDep"
                  stroke="#0062FF"
                  fillOpacity={1}
                  fill="url(#colorActual)"
                />
              </ComposedChart>
            </ResponsiveContainer>
          ) : null}
        </div>
    //   </TransformComponent>
    // </TransformWrapper>
  );
};

export default Graph;
