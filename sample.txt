/* src/App.js */
import { useRef, useEffect, useState } from "react";
import mapboxgl from "mapbox-gl";
import "mapbox-gl/dist/mapbox-gl.css";
import "./style.css";
import { useDispatch, useSelector, Provider } from "react-redux";
// import { TZFormatter, sortFlightData } from "../../../globals/common";
import moment from "moment";
import ReactDOM from "react-dom/client";
import store from "../../../redux/store/store";
import mapjson from "../../../assets/jsons/mapData.json"

let map = null;
let allMarkers = [];
let zones = [];
const Map = () => {
  const mapContainerRef = useRef(null);
  const [searchCoord, _setSearchCoord] = useState([]);
  const dispatch = useDispatch();
  const [MapApi,setMapApi] = useState({})

  const isloggedin = true
 
  const refData = mapjson ;

  const [_stationTerminalZone, setstationTerminalZone] = useState();
  const [planeMarker, setplaneMarker] = useState([]);
  const [activeTerminalWithCongestion, setactiveTerminalWithCongestion] =
    useState([]);
  const [activeTerminalWithLowPace, setactiveTerminalWithLowPace] = useState(
    []
  );
  const [
    activeTerminalWithPotentialCongestion,
    setactiveTerminalWithPotentialCongestion,
  ] = useState([]);
  const [activeTerminalWithoutAnamolies, setactiveTerminalWithoutAnamolies] =
    useState([]);
  const [terminalWithTimeline, setterminalWithTimeline] = useState([]);
  const [gates, _setGates] = useState(["C1", "C2"]);
  const [oddTerminal, _setOddTerminal] = useState([
    "C51",
    "C52",
    "C53",
    "C54",
    "C55",
    "C56",
    "C57"
  ]);
  useEffect(()=>{
    mapContainerRef?.current?.api?.resize()
  },[])

  // onclick flyto and zoom gate
  function flyToStore(currentFeature) {
    map?.flyTo({
      center: [currentFeature.gate.longitude, currentFeature.gate.latitude],
      zoom: 19,
    });
  }
  // flyto original position
  function flytoOriginal() {
    map?.flyTo({
      center: [MapApi.geolocation.longitude, MapApi.geolocation.latitude],
      zoom: MapApi.zoom,
    });
  }
  // search for gate
  function searchGate() {
    map?.flyTo({
      center: searchCoord,
      zoom: 19,
    });
  }


  // useEffect(() => {
  //   if (Object.keys(MapApi).length) {
  //     if (typeof selectedCardGateNo == "string" && selectedCardGateNo != "") {
  //       MapApi?.gates?.forEach((gateObj) => {
  //         if (gateObj.gateNum == selectedCardGateNo) {
  //           flyToStore(gateObj);
  //           return;
  //         }
  //       });
  //     } else {
  //       flytoOriginal();
  //     }
  //   }
  // }, [selectedCardGateNo]);

  // useEffect(() => {
  //   if (!isCardViewExpanded) {
  //     flytoOriginal();
  //   }
  // }, [isCardViewExpanded]);

  // useEffect(() => {
  //   // console.log("boardingCardboardingCard", boardingCard);
  //   if (Object.keys(boardingCard).length) {
  //     let tempPlaneMarkerObjArr = {
  //       withCongestion: [],
  //       withPotentialCongestion: [],
  //       without: [],
  //       withObjArr: [],
  //       withLowPace: [],
  //     };
  //     let tempPlaneMarkerArr = [];
  //     boardingCard?.boardingDetails?.forEach((card) => {
  //       // console.log("setactiveTerminalWithPotentialCongestion",card);
  //       // console.log("setactiveTerminalWithPotentialCongestion",card?.fltLeg);
  //       if (
  //         // card?.boardingStatus?.toLowerCase() === "open" &&
  //         // !(localStorage.getItem('role') === 'AOC' && card?.tailInfo)
  //         true
  //       ) {
  //         if (
  //           // card?.boardingInfo?.isCongestion
  //           card?.flightColour == "#D51D1D" 
  //           && card?.boardingInfo?.iaoActualBoardingStartTimeUTC
  //         ) {
  //           tempPlaneMarkerObjArr.withCongestion.push(card.gateNumber);
  //           // } else if (card?.boardingInfo?.isPotentialCongestion) {
  //           //   tempPlaneMarkerObjArr.withPotentialCongestion.push(card.gateNumber);
  //           // } else if (card?.boardingInfo?.isLowPace) {
  //           //   tempPlaneMarkerObjArr.withLowPace.push(card.gateNumber);
  //         } else if (
  //           card?.flightColour == "#50AC65" 
  //           && card?.boardingInfo?.iaoActualBoardingStartTimeUTC
  //         ) {
  //           tempPlaneMarkerObjArr.without.push(card.gateNumber);
  //         }
  //         tempPlaneMarkerObjArr.withObjArr.push(card);
  //       }
  //       // if (card?.flightStatus) {
  //         tempPlaneMarkerArr.push(card.gateNumber);
  //       // }
  //     });
  //     setplaneMarker(tempPlaneMarkerArr);
  //     setterminalWithTimeline(tempPlaneMarkerObjArr.withObjArr);
  //     setactiveTerminalWithCongestion(tempPlaneMarkerObjArr.withCongestion);
  //     setactiveTerminalWithPotentialCongestion(
  //       tempPlaneMarkerObjArr.withPotentialCongestion
  //     );
  //     setactiveTerminalWithLowPace(tempPlaneMarkerObjArr.withLowPace);
  //     setactiveTerminalWithoutAnamolies(tempPlaneMarkerObjArr.without);
  //   }
  // }, [boardingCard, userSelectedData]);

  // initialize map when component mounts
 
  useEffect(() => {
    // if (isloggedin) {
    //   dispatch(mapScreenAction.getRefData());
    // }
    return () => {
      if (map !== null) {
        map.remove();
        map = null;
        allMarkers = [];
      }
    };
  }, [isloggedin]);
  
  useEffect(() => {
    if (refData.length) {
      let station = [],
        terminal = [],
        zoneNbr = [],
        temp = { gates: [] };
      refData.forEach((stationitem) => {
        station.push(stationitem.stationName);
        stationitem.terminals.forEach((terminalItem) => {
          terminal.push(terminalItem.terminalName);
          terminalItem.zones.forEach((zoneItem) => {
            zoneNbr.push(zoneItem.zoneNumber);
          });
        });
      });
      refData.forEach((stationitem) => {
        stationitem.terminals.forEach((terminalItem) => {
          if (terminalItem.terminalName == terminal[0]) {
            zones = terminalItem.zones;
            terminalItem.zones.forEach((zoneItem) => {
              temp.gates.push(...JSON.parse(JSON.stringify(zoneItem.gates)));
              Object.keys(stationitem).forEach((item) => {
                if (typeof stationitem[item] == "string") {
                  temp[item] = stationitem[item];
                }
              });
              temp["terminals"] = terminalItem.terminalName;
              temp["zoneNbr"] = zoneItem.zoneNumber;
              temp["station"] = stationitem.stationName;
              temp["geolocation"] = stationitem.geolocation;
              // }
            });
          }
        });
      });
      // console.log("UPDATE_USER_DATA",refData[0].terminals[0].zones.map(zone => zone.zoneNumber));
      // dispatch({ type: mapConstants.SUCCESSRESPONSE, payload: temp });
      setMapApi(temp)
      dispatch({
        type: "UPDATE_USER_DATA",
        payload: {
          station: station[0],
          terminal: terminal[0],
          zoneNbr: refData?.[0]?.terminals?.[0]?.zones?.map(zone => zone.zoneNumber),
        },
      });
      //getFlightDetails(station[0], zoneNbr, terminal[0]);
      setstationTerminalZone({ station, terminal, zoneNbr });
    }
  }, [refData]);
  const getPolygonColor = (index) => {
    return index === 0 ? "#FF9300" : index === 1 ? "#0062FF" : "#65CB00";
  };
  useEffect(() => {
    if (Object.keys(MapApi).length && map === null) {
      // mapbox access token
      mapboxgl.accessToken = MapApi.mapkey;

      map = new mapboxgl.Map({
        container: mapContainerRef.current,
        // See style options here: https://docs.mapbox.com/api/maps/#styles
        style: MapApi.mapstyle, // 'mapbox://styles/mapbox/streets-v11',//
        center: [MapApi.geolocation.longitude, MapApi.geolocation.latitude], // starting position //,
        zoom: MapApi.zoom, // starting zoom
        bearing: MapApi.bearing,
        pitch: MapApi.pitch,
        attributionControl: false,
      });
      map?.addControl(new mapboxgl.NavigationControl(), "bottom-left");
      map.on("load", () => {
        if (zones?.length > 0) {
          // console.log("getPolygonColor", zones);
          zones.forEach((item, index) => {
            const colorForPolygon = getPolygonColor(index);
            // Add a data source containing GeoJSON data.
            map.addSource(`${item.zoneId}`, {
              type: "geojson",
              data: {
                type: "Feature",
                properties: {
                  title: `${item.zoneId}`,
                },
                geometry: {
                  type: "Polygon",
                  coordinates: item?.zoneCoordinates,
                },
              },
            });
            // Add a new layer to visualize the polygon.
            map.addLayer({
              id: `${item.zoneId}_fill`,
              type: "fill",
              source: `${item.zoneId}`, // reference the data source
              layout: {},
              paint: {
                "fill-color": item.zoneColor, // blue color fill
                "fill-opacity": 0.12,
              },
            });
            //Add a black outline around the polygon.
            map.addLayer({
              id: `${item.zoneId}_outline`,
              type: "line",
              source: `${item.zoneId}`,
              layout: {},
              paint: {
                "line-color": "#FFFCEF",
                "line-width": 2.5,
              },
            });
            // Add a symbol layer
            map.addLayer({
              id: `${item.zoneId}_symbol`,
              type: "symbol",
              source: `${item.zoneId}`,
              layout: {
                // get the title name from the source's "title" property
                "text-field": ["get", "title"],
                // 'text-font': [
                // 'Open Sans Semibold',
                // 'Arial Unicode MS Bold'
                // ],
                "text-offset": [0, 0],
                //'text-anchor': 'top'
              },
              paint: {
                "text-color": "#000",
                "text-opacity": 0.3,
              },
            });
          });
        }
      });
      map.on("click", (e) => {
        alert(e.lngLat.lng + "::" + e.lngLat.lat);
      });
    }
  }, [MapApi]); // eslint-disable-line react-hooks/exhaustive-deps

  useEffect(() => {
    if (map) {
      if (searchCoord.length >= 2) {
        searchGate();
      } else {
        flytoOriginal();
      }
    }
  }, [searchCoord]);

  const removeAllMarkers = () => {
    allMarkers.forEach((element) => {
      element.remove();
    });
    allMarkers = [];
  };

  const getPlaneMarkerClass = (feature) => {
    if(planeMarker.includes(feature.gateNum)){
      console.log("featureflightStatus",feature);
      let planeMarkerData = oddTerminal.includes(feature.gateNum)
        ? "planeDown"
        : "planeUp";
      let planeMarkerData2 = gates.includes(feature.gateNum)
        ? "rightPlane"
        : planeMarkerData;
  
      return planeMarkerData2
    }
    return ''
    // planeMarker && planeMarker.includes(feature.gateNum)
    //   ? planeMarkerData2
    //   : "";
  };

  const getMarkerClass = (feature) => {
    let className, imageClass = "cameraImageClass1"
    if (activeTerminalWithCongestion?.includes(feature.gateNum)) {
      className = "markerRed";
    } else if (activeTerminalWithoutAnamolies?.includes(feature.gateNum)) {
      className = "markerGreen";
    }else if (activeTerminalWithPotentialCongestion?.includes(feature.gateNum)) {
      className = "markerAmber";
    }else if (activeTerminalWithLowPace?.includes(feature.gateNum)) {
      className = "markerYellow";
    } else {
      className = `marker ${feature.isGateAvailable ? '' : 'greyText'}`;
      imageClass = "cameraImageClass";
    }
    return [className, imageClass]
  }

  const onClickGate = (feature, marker) => {
    // if ((localStorage.getItem('role') === 'SAOM' ? ['C52','C61']?.includes(feature.gateNum) : ['C52','C63','C61']?.includes(feature.gateNum))) {
      // need to comment. only for testing
      const popupNode = document.createElement("div");
      const root = ReactDOM.createRoot(popupNode);
      root.render(
        <Provider store={store}>
          {/* <BoardingCard
            shadowRequired={true}
            boardingCard={getBoardingCardObj(feature.gateNum)}
            mapPinPopupCard={getBoardingCardObj(feature.gateNum)}
          /> */}
          {/* <MapHowerCard shadowRequired={true} boardingCard={getBoardingCardObj(feature.gateNum)} /> */}
        </Provider>,
        popupNode
      );
      marker.setPopup(
        new mapboxgl.Popup({
          offset: 10,
          className: "popup",
        }) // add popups
          .setDOMContent(popupNode)
      );
    // }
  };

  useEffect(() => {
    if (map !== null) {
      // console.log("activeTerminalWithLowPace1", activeTerminalWithLowPace);
      removeAllMarkers();

      // markers for gate and planes
      if (MapApi?.gates?.length > 0) {
        for (const feature of MapApi?.gates) {
          // creating element for adding plane
          const ele = document.createElement("div");
          ele.className = getPlaneMarkerClass(feature);

          // const fltMarker = new mapboxgl.Marker(ele)
          //   .setLngLat([feature.btwgate.longitude, feature.btwgate.latitude])
          //   .addTo(map);
          // allMarkers.push(fltMarker);

          const fltMarker = new mapboxgl.Marker(ele,{rotation:oddTerminal.includes(feature.gateNum) ? "180" : "0"})
            .setLngLat([feature.btwgate.longitude, feature.btwgate.latitude])
            .addTo(map);
            allMarkers.push(fltMarker);

          // create a HTML element for each feature
          const el = document.createElement("a");
          el.setAttribute("id", feature.gateNum);
          el.appendChild(document.createTextNode(feature.gateNum));

          let classNames = getMarkerClass(feature);
          let imageClass = classNames[1];
          el.className = classNames[0];

          if (feature?.isCameraAvailable) {
            const img = document.createElement("div");
            img.className = imageClass;
            el.appendChild(img);
          }

          // for search gates
          if (searchCoord.length === 2) {
            searchGate();
          }
          // make a marker for each feature and add to the map
          //new mapboxgl.Marker(el).setLngLat(feature.geometry.coordinates).addTo(map);

          const marker = new mapboxgl.Marker(el).setLngLat([
            feature.gate.longitude,
            feature.gate.latitude,
          ]);

          el.addEventListener("click", () => {
            onClickGate(feature, marker);
          });

          marker.addTo(map);
          allMarkers.push(marker);
        }

        // console.log(
        //   "activeTerminalWithLowPace2",
        //   terminalWithTimeline,
        //   planeMarker,
        //   activeTerminalWithCongestion,
        //   activeTerminalWithPotentialCongestion,
        //   activeTerminalWithoutAnamolies,
        //   activeTerminalWithLowPace
        // );
      }
    }
  }, [
    terminalWithTimeline,
    planeMarker,
    activeTerminalWithCongestion,
    activeTerminalWithPotentialCongestion,
    activeTerminalWithoutAnamolies,
    activeTerminalWithLowPace,
  ]);
  return (
    // <div className="container">
    <div className="map-container" ref={mapContainerRef} >
      {/* <LocalUtcTime /> */}
      {/* <TimerSlide /> */}
      {/* <SearchTerminal setSearchCoord={setSearchCoord} /> */}
      {/* <MapHorizontalCardList /> */}
    </div>
    // </div>
  );
};

export default Map;
