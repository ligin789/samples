/* src/App.js */
import { useRef, useEffect, useState } from "react";
import mapboxgl from "mapbox-gl";
import "mapbox-gl/dist/mapbox-gl.css";
import "./style.css";
import { useDispatch, useSelector, Provider } from "react-redux";
// import { TZFormatter, sortFlightData } from "../../../globals/common";
import moment from "moment";
import ReactDOM from "react-dom/client";
import store from "../../../redux/store/store";
import TerminalSelect from "../../terminalSelect";
import TimerSlide from "../../TimerSlide/index"

let map = null;
let allMarkers = [];
let zones = [];
const Map = (props) => {
  const {mapData=[],flightClicked,setFlightClicked,onClickFlight,dropDownIndex,handleDropDownIndex }=props
  const mapContainerRef = useRef(null);
  const [searchCoord, _setSearchCoord] = useState([]);
  const dispatch = useDispatch();
  const [MapApi,setMapApi] = useState({})

  const isloggedin = true
 
  const refData = mapData ;

  const [_stationTerminalZone, setstationTerminalZone] = useState();
  const [planeMarker, setplaneMarker] = useState([]);
  const [activeTerminalWithCongestion, setactiveTerminalWithCongestion] =
    useState([]);
  const [activeTerminalWithLowPace, setactiveTerminalWithLowPace] = useState(
    []
  );
  const [
    activeTerminalWithPotentialCongestion,
    setactiveTerminalWithPotentialCongestion,
  ] = useState([]);
  const [activeTerminalWithoutAnamolies, setactiveTerminalWithoutAnamolies] =
    useState([]);
  const [terminalWithTimeline, setterminalWithTimeline] = useState([]);
  const [gates, _setGates] = useState(["C1", "C2"]);
  const [oddTerminal, _setOddTerminal] = useState([
    "47"
  ]);
  const [selectedTerminal,setSelectedTerminal] = useState("Terminal 1")
  const [userSelectedData,setUserSelectedData]= useState({})
  useEffect(()=>{
    mapContainerRef?.current?.api?.resize()
  },[])

  // onclick flyto and zoom gate
  function flyToStore(currentFeature) {
    map?.flyTo({
      center: [currentFeature.gate.longitude, currentFeature.gate.latitude],
      zoom: 19,
    });
  }
  // flyto original position
  function flytoOriginal() {
    map?.flyTo({
      center: [MapApi.geolocation.longitude, MapApi.geolocation.latitude],
      zoom: MapApi.zoom,
    });
  }
  // search for gate
  function searchGate() {
    map?.flyTo({
      center: searchCoord,
      zoom: 19,
    });
  }

  useEffect(() => {
    // if (isloggedin) {
    //   dispatch(mapScreenAction.getRefData());
    // }
    return () => {
      if (map !== null) {
        map.remove();
        map = null;
        allMarkers = [];
      }
    };
  }, [isloggedin]);
  
  useEffect(() => {
    if (refData.length) {
      let station = [], terminal = [], zoneNbr = []
      refData.forEach((stationitem) => {
        station.push(stationitem.stationName)
        stationitem.terminals.forEach((terminalItem) => {
          terminal.push(terminalItem.terminalName)
          let tempZone = []
          terminalItem.zones.forEach((zoneItem) => {
            tempZone.push(zoneItem.zoneNumber)
          })
          zoneNbr.push(tempZone)
        })
      })
      setUserSelectedData( {
        station: station[0],
        terminal: selectedTerminal,
        zoneNbr: zoneNbr[0],
      })
      map = null
      setstationTerminalZone({ station, terminal, zoneNbr })
    }
  }, [refData,selectedTerminal])
  useEffect(() => {
    let temp = { gates: [] }
    let geoLocation = {}
    refData.forEach((stationitem) => {
      if(stationitem.stationName == userSelectedData.station){
        stationitem.terminals.forEach((terminalItem) => {
          if (terminalItem.terminalName == userSelectedData.terminal) {
            geoLocation=terminalItem.geolocation
            zones = terminalItem.zones;
            terminalItem.zones.forEach((zoneItem) => {
              temp.gates.push(...JSON.parse(JSON.stringify(zoneItem.gates)))
              Object.keys(stationitem).forEach((item) => {
                if (typeof stationitem[item] == 'string') {
                  temp[item] = stationitem[item]
                }
              })
              temp['terminals'] = terminalItem.terminalName
              temp['zoneNbr'] = zoneItem.zoneNumber
              temp['station'] = stationitem.stationName
              temp['geolocation'] = geoLocation || stationitem.geolocation
            })
          }
        })
      }
      })
      // console.log("UPDATE_USER_DATA",refData[0].terminals[0].zones.map(zone => zone.zoneNumber));
      // dispatch({ type: mapConstants.SUCCESSRESPONSE, payload: temp });
      setMapApi(temp)
      
      //setstationTerminalZone({ station, terminal, zoneNbr });
    
  }, [userSelectedData]);
  const getPolygonColor = (index) => {
    return index === 0 ? "#FF9300" : index === 1 ? "#0062FF" : "#65CB00";
  };
  useEffect(() => {
    if (Object.keys(MapApi).length && map === null && MapApi?.geolocation?.longitude && MapApi?.geolocation?.latitude) {
      // mapbox access token
      mapboxgl.accessToken = MapApi.mapkey;

      map = new mapboxgl.Map({
        container: mapContainerRef.current,
        // See style options here: https://docs.mapbox.com/api/maps/#styles
        style: MapApi.mapstyle, // 'mapbox://styles/mapbox/streets-v11',//
        center: [MapApi?.geolocation?.longitude, MapApi?.geolocation?.latitude], // starting position //,
        zoom: MapApi.zoom, // starting zoom
        bearing: MapApi.bearing,
        pitch: MapApi.pitch,
        attributionControl: false,
      });
      map?.addControl(new mapboxgl.NavigationControl(), "bottom-left");
      map.on("load", () => {
        if (zones?.length > 0) {
          // console.log("getPolygonColor", zones);
          zones.forEach((item, index) => {
            const colorForPolygon = getPolygonColor(index);
            // Add a data source containing GeoJSON data.
            map.addSource(`${item.zoneId}`, {
              type: "geojson",
              data: {
                type: "Feature",
                properties: {
                  title: `${item.zoneId}`,
                },
                geometry: {
                  type: "Polygon",
                  coordinates: item?.zoneCoordinates,
                },
              },
            });
            // Add a new layer to visualize the polygon.
            map.addLayer({
              id: `${item.zoneId}_fill`,
              type: "fill",
              source: `${item.zoneId}`, // reference the data source
              layout: {},
              paint: {
                "fill-color": item.zoneColor, // blue color fill
                "fill-opacity": 0.5,
              },
            });
            //Add a black outline around the polygon.
            map.addLayer({
              id: `${item.zoneId}_outline`,
              type: "line",
              source: `${item.zoneId}`,
              layout: {},
              paint: {
                "line-color": "#FFFCEF",
                "line-width": 2.5,
              },
            });
            // Add a symbol layer
            map.addLayer({
              id: `${item.zoneId}_symbol`,
              type: "symbol",
              source: `${item.zoneId}`,
              layout: {
                // get the title name from the source's "title" property
                "text-field": ["get", "title"],
                // 'text-font': [
                // 'Open Sans Semibold',
                // 'Arial Unicode MS Bold'
                // ],
                "text-offset": [0, 0],
                //'text-anchor': 'top'
              },
              paint: {
                "text-color": "#000",
                "text-opacity": 0.3,
              },
            });
          });
        }
        setTimeout(() => {
          map?.resize();
        }, 1000);
        
      });
      //let a=[]
      map.on("click", (e) => {
        // a.push([e.lngLat.lng,e.lngLat.lat])
         //alert(e.lngLat.lng + "::" + e.lngLat.lat);
      });
      //console.log(a)
    }
  }, [MapApi]); // eslint-disable-line react-hooks/exhaustive-deps

  useEffect(() => {
    if (map) {
      if (searchCoord.length >= 2) {
        searchGate();
      } else {
        flytoOriginal();
      }
    }
  }, [searchCoord]);

  const removeAllMarkers = () => {
    allMarkers.forEach((element) => {
      element.remove();
    });
    allMarkers = [];
  };

  const getPlaneMarkerClass = (feature) => {
    if(feature?.isGateOccupied==true){
      console.log("featureflightStatus",feature);
      let planeMarkerData = oddTerminal.includes(feature.gateNum)
        ? "planeUp"
        : "planeDown";
      let planeMarkerData2 = gates.includes(feature.gateNum)
        ? "rightPlane"
        : planeMarkerData;
  
      return planeMarkerData2
    }
    return ''
    // planeMarker && planeMarker.includes(feature.gateNum)
    //   ? planeMarkerData2
    //   : "";
  };

  const getMarkerClass = (feature) => {
    let className, imageClass = "cameraImageClass1"
    if (activeTerminalWithCongestion?.includes(feature.gateNum)) {
      className = "markerRed";
    } else if (activeTerminalWithoutAnamolies?.includes(feature.gateNum)) {
      className = "markerGreen";
    }else if (activeTerminalWithPotentialCongestion?.includes(feature.gateNum)) {
      className = "markerAmber";
    }else if (activeTerminalWithLowPace?.includes(feature.gateNum)) {
      className = "markerYellow";
    } else {
      className = `marker ${feature.isGateAvailable ? '' : 'greyText'}`;
      imageClass = "cameraImageClass";
    }
    return [className, imageClass]
  }

  const onClickGate = (feature, marker) => {
    // if ((localStorage.getItem('role') === 'SAOM' ? ['C52','C61']?.includes(feature.gateNum) : ['C52','C63','C61']?.includes(feature.gateNum))) {
      // need to comment. only for testing
      const popupNode = document.createElement("div");
      const root = ReactDOM.createRoot(popupNode);
      root.render(
        <Provider store={store}>
          {/* <BoardingCard
            shadowRequired={true}
            boardingCard={getBoardingCardObj(feature.gateNum)}
            mapPinPopupCard={getBoardingCardObj(feature.gateNum)}
          /> */}
          {/* <MapHowerCard shadowRequired={true} boardingCard={getBoardingCardObj(feature.gateNum)} /> */}
        </Provider>,
        popupNode
      );
      marker.setPopup(
        new mapboxgl.Popup({
          offset: 10,
          className: "popup",
        }) // add popups
          .setDOMContent(popupNode)
      );
    // }
  };
  const getSvgDataUrl = (color,upDownState) => {
    const svg = upDownState?
                 `<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40">
                  <path id="Path_1909" data-name="Path 1909" d="M657.266,957c.932.215,2.469,1.64,2.546,4.684s0,8.492,0,8.492l3.031,2.077s.168-1.844,1.749-1.844a1.541,1.541,0,0,1,1.564,1.6v2.432l1.652,1.214a2.074,2.074,0,0,1,1.79-1.214,1.3,1.3,0,0,1,1.345,1.214v2.03l6.33,4.282V985l-17.26-6.658-1.191,12.4,6.71,4.687.337,1.578-7.384-1.867L658.029,997H656.6l-.5-1.867L648.627,997l.326-1.578,6.905-4.687-1.352-12.4-17.234,6.59v-3.036l6.23-4.135v-2.012a1.287,1.287,0,0,1,1.314-1.36,1.616,1.616,0,0,1,1.737,1.178l1.818-1.178V971.9s.131-1.55,1.529-1.55,1.638,1.55,1.638,1.55v.384l3.231-2.107v-8.492S654.635,958.385,657.266,957Z" transform="translate(677.271 997) rotate(180)" fill="${color}"/>
                  </svg>`
                : `<svg xmlns="http://www.w3.org/2000/svg" width="175.509" height="179.094" viewBox="0 0 175.509 179.094">
                  <path id="Path_1827" data-name="Path 1827" d="M725,957c4.091.963,10.831,7.341,11.17,20.971s0,38.021,0,38.021l13.3,9.3s.737-8.255,7.674-8.255,6.865,7.153,6.865,7.153v10.891l7.247,5.435s2.3-5.435,7.855-5.435,5.9,5.435,5.9,5.435v9.088l27.772,19.174v13.577l-75.73-29.809-5.225,55.5,29.44,20.983,1.48,7.066-32.4-8.358-2,8.358h-6.261l-2.185-8.358-32.807,8.358,1.429-7.066,30.3-20.983-5.932-55.5-75.62,29.506v-13.595l27.335-18.515v-9.009s-.429-5.566,5.764-6.089a7.125,7.125,0,0,1,7.622,5.275l7.977-5.275V1023.7s.576-6.938,6.708-6.938,7.185,6.938,7.185,6.938v1.722l14.178-9.433V977.971S713.459,963.2,725,957Z" transform="translate(-637.272 -957)" fill="${color}"/>
                  </svg>`
    return `data:image/svg+xml,${encodeURIComponent(svg)}`;
  };

  useEffect(() => {
    if (map !== null) {
      // console.log("activeTerminalWithLowPace1", activeTerminalWithLowPace);
      removeAllMarkers();

      // markers for gate and planes
      if (MapApi?.gates?.length > 0) {
        for (const feature of MapApi?.gates) {
          // creating element for adding plane
          const ele = document.createElement("div");
          ele.className = getPlaneMarkerClass(feature);

          // const fltMarker = new mapboxgl.Marker(ele)
          //   .setLngLat([feature.btwgate.longitude, feature.btwgate.latitude])
          //   .addTo(map);
          // allMarkers.push(fltMarker);

          const fltMarker = new mapboxgl.Marker(ele,{rotation:oddTerminal.includes(feature.gateNum) ? "0" : "0"})
            .setLngLat([feature.btwgate.longitude, feature.btwgate.latitude])
            .addTo(map);
            let updown = getPlaneMarkerClass(feature)
            Object.assign(ele.style, {
              backgroundImage: `url("${getSvgDataUrl(feature?.aircraftColor, updown.includes("Down"))}")`,
              backgroundSize: "cover",
            })
            
            ele.addEventListener("click", () => {
              onClickFlight(feature);
            });

            allMarkers.push(fltMarker);
          // create a HTML element for each feature
          const el = document.createElement("a");
          el.setAttribute("id", feature.gateNum);
          el.appendChild(document.createTextNode(feature.gateNum));

          let classNames = getMarkerClass(feature);
          let imageClass = classNames[1];
          el.className = classNames[0];

          if (feature?.isCameraAvailable) {
            const img = document.createElement("div");
            img.className = imageClass;
            el.appendChild(img);
          }

          // for search gates
          if (searchCoord.length === 2) {
            searchGate();
          }
          // make a marker for each feature and add to the map
          //new mapboxgl.Marker(el).setLngLat(feature.geometry.coordinates).addTo(map);

          const marker = new mapboxgl.Marker(el).setLngLat([
            feature.gate.longitude,
            feature.gate.latitude,
          ]);

          // el.addEventListener("click", () => {
          //   onClickGate(feature, marker);
          // });

          marker.addTo(map);
          allMarkers.push(marker);
        }

        // console.log(
        //   "activeTerminalWithLowPace2",
        //   terminalWithTimeline,
        //   planeMarker,
        //   activeTerminalWithCongestion,
        //   activeTerminalWithPotentialCongestion,
        //   activeTerminalWithoutAnamolies,
        //   activeTerminalWithLowPace
        // );
      }
    }
  }, [
    terminalWithTimeline,
    MapApi
  ]);
  return (
    // <div className="container">
    <div className="map-container" ref={mapContainerRef} style={{top: flightClicked?"284px": "190px"}} onClick={()=> dropDownIndex !== -1 && handleDropDownIndex(-1)}>
      {/* <TimerSlide MapApi={MapApi} /> */}
      <TerminalSelect _stationTerminalZone={_stationTerminalZone} selectedTerminal={selectedTerminal} setSelectedTerminal={setSelectedTerminal} dropDownIndex={dropDownIndex} handleDropDownIndex={handleDropDownIndex}/>
      {/* <SearchTerminal setSearchCoord={setSearchCoord} /> */}
      {/* <MapHorizontalCardList /> */}
    </div>
    // </div>
  );
};

export default Map;
