import { useState, useEffect, useRef } from "react";
// import Button from "@material-ui/core/Button";
// import ButtonGroup from "@material-ui/core/ButtonGroup";
import "./timerSlide.css";
import moment from "moment";
import configurationDetails from "./Configuration";
import {  localTimezoneConversion } from "../../global/timeConversion";
import { makeStyles } from "@mui/styles";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faMinus, faPlus } from "@fortawesome/free-solid-svg-icons";
import SliderWithAnomalies from "../sliderWithAnomalies";
// import { ReactComponent as Previous } from "../../assets/previous.svg";
// import { ReactComponent as Next } from "../../assets/next.svg";
// import { ReactComponent as PreviousDisable } from "../../assets/previousDisable.svg";
// import { ReactComponent as NextDisable } from "../../assets/nextDisable.svg";
import { useDispatch, useSelector } from "react-redux";
import Colors from "../../global/Color";

const useStyles = makeStyles({
  icon: {
    "&.MuiButtonGroup-grouped": {
      minWidth: "26px",
    },
  },
}, { index: 1 });

let heartbeatfortimeframe: any

function TimerSlide(_props: any) {
  const classes = useStyles();
  const [initialScroll, setinitialScroll] = useState<any>()
  const [currDate, setcurrDate] = useState(localTimezoneConversion())
  const [interval, setinterval] = useState<number>(
    configurationDetails.timerVal.varies
  ); //Setting default time interval
  const [actualTiming, setActualTiming] = useState<
    Array<{
      timerVal: any;
      currentTimer: any;
    }>
  >([]);
  const [displayTiming, setDisplayTiming] = useState<
    Array<{
      timerVal: any;
      currentTimer: any;
    }>
  >([]); //Setting default time interval

  const [scrollX, setscrollX] = useState<number>(0); // For detecting start scroll postion
  const [scrolEnd, setscrolEnd] = useState<boolean>(false); // For detecting end of scrolling
  const [heartBeat, setheartBeat] = useState<boolean>(false);
  const [trigger, settrigger] = useState<boolean>(false)
  const [update] = useState(0);
  const [currTimeClicked, setcurrTimeClicked] = useState<boolean>(false)
  const dispatch = useDispatch();
  // const refData = useSelector((state: any) => state.mapDataReducer.refData)
  // const isloggedin = useSelector((state: any) => state.UserData.isValidUserLoggedIn)

  const scrollElement: any = useRef(null);
  const scrollLeft = (scrollOffset: number) => {
    scrollElement.current.scrollLeft += scrollOffset;
    setscrollX(scrollX + scrollOffset); // Updates the latest scrolled postion

    //For checking if the scroll has ended
    if (
      // Math.floor(
      //   scrollElement.current.scrollWidth - scrollElement.current.scrollLeft + 300
      // ) <= scrollElement.current.offsetWidth
      scrollElement.current.scrollWidth < scrollX + scrollOffset + scrollElement.current.offsetWidth
    ) {
      setscrolEnd(true);
    } else {
      setscrolEnd(false);
    }
  };

  //This will check scroll event and checks for scroll end
  const scrollCheck = () => {

    setscrollX(scrollElement.current.scrollLeft);
    // console.log("scrollCheck",scrollElement.current.scrollLeft);
    
    if (
      Math.floor(
        scrollElement.current.scrollWidth - scrollElement.current.scrollLeft
      ) <= scrollElement.current.offsetWidth
    ) {
      setscrolEnd(true);
    } else {
      setscrolEnd(false);
    }
  };

  useEffect(() => {
    //Check width of the scollings
    if (
      scrollElement.current &&
      scrollElement?.current?.scrollWidth ===
      scrollElement?.current?.offsetWidth
    ) {
      setscrolEnd(true);
    } else {
      setscrolEnd(false);
    }
  }, [
    scrollElement?.current?.scrollWidth,
    scrollElement?.current?.offsetWidth,
  ]);

  // On Click Event for Set time Interval on inc/dec
  const incrementInterval = () => {
    setinterval(interval + configurationDetails.timerVal.varies);
    scrollCheck();
  };
  const decrementInterval = () => {
    setinterval(interval - configurationDetails.timerVal.varies);
    scrollCheck();
  };

  useEffect(() => {
    let currentDateTime: any = localTimezoneConversion().startOf("hour");

    let startDateTime: any = localTimezoneConversion(currentDateTime).subtract(
      configurationDetails.timeSlider.startTimer,
      "h"
    );

    let totalHRDisplay: number =
      (configurationDetails.timeSlider.startTimer +
        configurationDetails.timeSlider.endTimer) *
      (60 / 1);
    let timer: any[] = [];
    let tempTimer: any[] = []
    for (let index = 0; index <= totalHRDisplay; index++) {
      let nextstartDateTime = localTimezoneConversion(startDateTime).add(
        1,
        "m"
      );
      if ((index) % interval == 0) {
        timer.push({
          timerVal: startDateTime,
          currentTimer: localTimezoneConversion().isBetween(
            startDateTime,
            nextstartDateTime
          ),
        });
      }
      tempTimer.push({
        timerVal: startDateTime,
        currentTimer: localTimezoneConversion().isBetween(
          startDateTime,
          nextstartDateTime
        ),
      })
      if (tempTimer.at(-1).currentTimer) {
        setcurrDate(tempTimer.at(-1).timerVal)
        setinitialScroll(Math.floor(tempTimer.length / interval) * 50 - Math.floor(scrollElement.current.offsetWidth / 2) - 45)    // 50 is scrollvalue b/t 2 time lables and 45 is some additional value for making it as center
      }
      startDateTime = nextstartDateTime;
    }

    if (tempTimer.length) {
      setActualTiming(tempTimer)
      setDisplayTiming(timer);
    }

  }, [interval, update, heartBeat]);


  // const callTimeFrameApi = () => {
  //   // if(actualTiming && actualTiming[0] && actualTiming[0].timerVal)
  //   dispatch(mapScreenAction.getTimeFrame({
  //     "bucketFromTime": TZFormatter(moment().utc().subtract(configuration.defaultValues.timerStartHrs, 'hours')), //actualTiming[0].timerVal.format('YYYY:MM:DDTHH:mm:ss'), //"2023-07-06T15:23:00",
  //     "bucketToTime": TZFormatter(moment().utc().add(configuration.defaultValues.timerEndHrs, 'hours')), //actualTiming[actualTiming.length-1].timerVal.format('YYYY:MM:DDTHH:mm:ss'), //"2023-07-06T15:26:00",
  //     "departureStation": refData[0].stationName,
  //     "enterpriseCode": "UA"
  //   }))
  // }

  // useEffect(() => {
  //   if (actualTiming.length && refData.length) {
  //     callTimeFrameApi()
  //   }
  // }, [actualTiming.length, refData])

  // useEffect(() => {
  //   if (refData.length) {
  //     heartbeatfortimeframe = setInterval(() => {
  //       if (isloggedin) {
  //         callTimeFrameApi()
  //       } else {
  //         clearInterval(heartbeatfortimeframe)
  //         heartbeatfortimeframe = null
  //       }
  //     }, 10000)
  //   }

  // }, [refData, isloggedin])

  // useEffect(() => {
  //   if (!isloggedin) {
  //     clearInterval(heartbeatfortimeframe)
  //     heartbeatfortimeframe = null
  //   }
  // }, [isloggedin])

  useEffect(() => {
    setTimeout(() => {
      settrigger(true)
    }, (60 - parseInt(localTimezoneConversion().format('ss'))) * 1000)
    return () => {
      clearInterval(heartbeatfortimeframe)
      heartbeatfortimeframe = null
    }
  }, [])

  useEffect(() => {
    let heartBeatInterval: any
    if (trigger) {
      heartBeatInterval = setInterval(() => {
        setheartBeat((prevState) => !prevState)
      }, 60000)
    }
    return () => {
      clearInterval(heartBeatInterval)
      heartBeatInterval = null
    }
  }, [trigger])

  //Horizontal scroll to the current time element
  useEffect(() => {
    let hrScrollElement = setTimeout(() => {
      const element = document.getElementById("current-indicator");
      element &&
        element.scrollIntoView({ behavior: "smooth", inline: "center" });
    }, 1000);

    return () => {
      clearTimeout(hrScrollElement);
    };
  }, []);


  const currentTimeHandler = () => {
    // setUpdate(update=>update+1)
    setcurrTimeClicked(true)
    setcurrDate((localTimezoneConversion()))
    // setinitialScroll(Math.floor(actualTiming.length / interval) * 50 - Math.floor(scrollElement.current.offsetWidth / 2))
  }

  return (
    <>
      <div style={{ width: `calc( 100vw - 113px)` }} className="current-time">

        <span

          style={{

            color: "#000000D0",

            fontSize: "15px",

            position: 'absolute',
            left: "130px",
            fontWeight: '500',
            textTransform: "uppercase"

          }}>{
            currDate.format(" DD MMM YYYY ")
            // `04 APRIL 2024`
          }</span>

      </div>
      <div style={{ width: `calc( 100vw - 50px )` }} className="time-liner">
        <div className="button-section" >
          <div
            // size="small"
            aria-label="small outlined button group"
            className="button-group"
            style={{backgroundColor:Colors.common}}
          >
            <button
              className={classes.icon}
              disabled={
                interval <= configurationDetails.timerVal.minValue
                  ? true
                  : false
              }
              onClick={decrementInterval}
              style={{backgroundColor:Colors.common}}
            >
              <FontAwesomeIcon
                icon={faMinus}
                style={{ color: interval <= configurationDetails.timerVal.minValue ? 'grey' : Colors.headingText, fontSize: "12px" }}
              />
            </button>
            <span className="minutes-variant">{`${interval} MIN`}</span>
            <button
              className={classes.icon}
              disabled={
                interval >= configurationDetails.timerVal.maxValue
                  ? true
                  : false
              }
              onClick={incrementInterval}
              style={{backgroundColor:Colors.common}}
            >
              <FontAwesomeIcon
                icon={faPlus}
                style={{ color: interval >= configurationDetails.timerVal.maxValue ? 'grey' : Colors.headingText, fontSize: "12px" }}
              />
            </button>
          </div>
        </div>
        <div className="time-line-contain">
          <div style={{ height: '26px', display: 'flex' }}>
            <div
              style={{
                backgroundColor: Colors.common, height: "100%",
                marginTop: "14px",
                width: "14px",
                borderBottomLeftRadius: "30px",
                borderTopLeftRadius: "30px"
              }}
              className="left-end"
            >
              {/* &nbsp;&nbsp;&nbsp; */}
            </div>

            <SliderWithAnomalies updateCurrDate={(date: any) => setcurrDate(date)} initialScroll={initialScroll} interval={interval} onScroll={scrollCheck} parentDiv={scrollElement} actualTiming={actualTiming} displayTiming={displayTiming} currentTimeClicked={currTimeClicked} resetCurrTimeClicked={setcurrTimeClicked} />

            <div
              style={{
                backgroundColor: Colors.common, height: "100%",
                marginTop: "14px",
                width: "16px",
                borderBottomRightRadius: "30px",
                borderTopRightRadius: "30px",
                display: 'flex',
                alignItems: 'center'
              }}
              className="prev-nxt"
            >
              {/* {scrollX === 0 ? (
                <PreviousDisable className="previous-button" />
              ) : (
                <Previous
                  className="previous-button"
                  onClick={() => scrollLeft(-300)}
                />
              )}
              {scrolEnd ? (
                <NextDisable />
              ) : (
                <Next onClick={() => scrollLeft(300)} />
              )} */}
            </div>
          </div>
          {/* <div
            style={{
              backgroundImage: `url(${RightEnd})`,
              backgroundRepeat: "no-repeat",
            }}
            className="right-end"
          >
            &nbsp;&nbsp;&nbsp;
          </div> */}
        </div>
      </div>
    </>
  );
}

export default TimerSlide;
